'use server';

/**
 * Server actions module
 * Contains all server-side actions for data manipulation and business logic
 * @module actions
 */

import { signIn, signOut } from '@/auth';
import { AuthError } from 'next-auth';
import { revalidatePath } from 'next/cache';
import { redirect } from 'next/navigation';
import { CreateProjectFormSchema, UpdateProjectSchema } from '@/app/lib/zodschemas';
import { 
  createProject, updateProject, updateExpense, createExpense, deleteExpense,
  updateProjectResource, createProjectResource, deleteProjectResource,
  updatePerson, createPerson, deletePerson,
  updateRole, createRole, deleteRole,
  updateCategory, createCategory, deleteCategory,
  fetchProjectBudgetReport, updateProjectCategoryBudget,
  deleteProject, fetchTopProjects,
  fetchCategories, fetchProjectById 
} from './dataaccess';
import { 
  Project, ProjectExpense, VProjectResources, 
  VPerson, VRole, VCategory
} from './dataschemas';

/**
 * Type definition for project creation state
 * Used for form validation and error handling
 */
export type CreateProjectState = {
  errors?: {
    project_id?: string[];
    project_name?: string[];
    project_start_date?: string[];
    project_end_date?: string[];
    project_creation_date?: string[];
    project_manager_id?: string[];
  };
  message?: string | null;
};

/**
 * Authenticates a user using credentials
 * @param {string | undefined} prevState - Previous authentication state
 * @param {FormData} formData - Form data containing credentials
 * @returns {Promise<string>} Error message if authentication fails
 */
export async function authenticate(
  prevState: string | undefined,
  formData: FormData,
) {
  try {
    await signIn('credentials', formData);
  } catch (error) {
    if (error instanceof AuthError) {
      switch (error.type) {
        case 'CredentialsSignin':
          return 'Invalid credentials.';
        default:
          return 'Something went wrong.';
      }
    }
    throw error;
  }
}

/**
 * Logs out the current user
 * Redirects to home page after logout
 */
export async function unauthenticate() {
  await signOut({redirectTo: '/'});
}

/*
 * Project creation
 * The form validation is done using Zod
 * The form data is validated and then inserted into the database
 * 
 * FIXME - we could also complement with client-side validation
 */
 
// Omit a few values that will be calculated
// project_id is autogenerated by the database as UUID
// project_creation_date is autogenerated by this action
const CreateProject = CreateProjectFormSchema.omit({ project_id: true, project_creation_date: true });

/**
 * Creates a new project
 * @param {CreateProjectState} prevState - Previous form state
 * @param {FormData} formData - Project form data
 * @returns {Promise<{errors?: object, message?: string}>} Validation result or error
 */
export async function createProjectAction(prevState: CreateProjectState | undefined, formData: FormData) {

  // Validate form using Zod
  const validatedFields = CreateProject.safeParse({
    project_id: formData.get('project_id'),
    project_name: formData.get('project_name'),
    project_start_date: formData.get('project_start_date'),
    project_end_date: formData.get('project_end_date'),
    project_manager_id: formData.get('project_manager_id'),
  });

  //const rawFormData = Object.fromEntries(formData.entries())

  // If form validation fails, return errors early. Otherwise, continue.
  if (!validatedFields.success) {
    console.log("Validation error: ", JSON.stringify(validatedFields));
    return {
      errors: validatedFields.error.flatten().fieldErrors,
      message: 'Missing Fields. Failed to create project.',
    };
  }

  // Prepare data for insertion into the database
  const { project_name, project_start_date, project_end_date, project_manager_id } = validatedFields.data;

  // Please note that we are not providing project_id or project_scope
  // The former will be calculated by the database, the latter will require a bigger UI so we
  // leave it empty for now and force the user to fill it out properly in the project details page
  const project = {
    project_id: "",
    project_name: project_name,
    project_start_date: project_start_date,
    project_end_date: project_end_date,
    project_scope: "",
    project_manager_id: project_manager_id
  };

  try {
    await createProject(project);
    console.log('Project successfully added to database');
  } catch (error) {
    console.error('Failed to add project:', error);
    throw error;
  }

  // Revalidate the cache for the invoices page and redirect the user.
  revalidatePath('/main');
  redirect('/main');
}

/**
 * Updates an existing project
 * @param {unknown} prevState - Previous form state
 * @param {FormData} formData - Updated project data
 * @returns {Promise<{error?: string}>} Error message if update fails
 */
export async function updateProjectAction(
  prevState: unknown,
  formData: FormData
) {
  const data = {
    project_id: formData.get('project_id'),
    project_name: formData.get('project_name'),
    project_scope: formData.get('project_scope'),
    project_start_date: new Date(formData.get('project_start_date') as string),
    project_end_date: new Date(formData.get('project_end_date') as string),
    project_manager_id: formData.get('project_manager_id'),
  };

  try {
    const result = UpdateProjectSchema.safeParse(data);
    if (!result.success) {
      return { error: 'Invalid form data' };
    }
    await updateProject(data as Project);
    revalidatePath(`/main/projects/${data.project_id}`);
  } catch (error) {
    console.log(JSON.stringify({ 
      error: 'Failed to update project ' + JSON.stringify(error) 
    }));
    return { 
      error: 'Failed to update project ' + JSON.stringify(error) 
    };
  }
  redirect('/main');
  //return { success: true }; - cannot really return as we are redirecting
}

/**
 * Updates a project expense
 * @param {string} expenseId - ID of expense to update
 * @param {Partial<ProjectExpense>} data - Updated expense data
 * @returns {Promise<{success: boolean, expense?: ProjectExpense, error?: string}>}
 */
export async function updateExpenseAction(expenseId: string, data: Partial<ProjectExpense>) {
  try {
    console.log("UPDATE EXPENSE", expenseId, JSON.stringify(data))
    const updatedExpense = await updateExpense(expenseId, data);
    return { success: true, expense: updatedExpense };
  } catch (error) {
    console.error('Action error:', error);
    return { success: false, error: 'Failed to update expense' };
  }
}

/**
 * Creates a new expense
 * @param {Partial<ProjectExpense>} data - Expense data to create
 * @returns {Promise<{success: boolean, expense?: ProjectExpense, error?: string}>}
 */
export async function createExpenseAction(data: Partial<ProjectExpense>) {
  try {
    const newExpense = await createExpense(data);
    return { success: true, expense: newExpense };
  } catch (error) {
    console.error('Action error:', error);
    return { success: false, error: 'Failed to create expense' };
  }
}

/**
 * Deletes an expense
 * @param {string} expenseId - ID of expense to delete
 * @returns {Promise<{success: boolean, error?: string}>}
 */
export async function deleteExpenseAction(expenseId: string) {
  try {
    await deleteExpense(expenseId);
    return { success: true };
  } catch (error) {
    console.error('Action error:', error);
    return { success: false, error: 'Failed to delete expense' };
  }
}

/**
 * Updates a project resource assignment
 * @param {string} projectId - Project identifier
 * @param {string} personId - Person identifier
 * @param {Partial<VProjectResources>} data - Updated resource data
 * @returns {Promise<{success: boolean, resource?: VProjectResources, error?: string}>}
 */
export async function updateProjectResourceAction(
  projectId: string, 
  personId: string, 
  data: Partial<VProjectResources>
) {
  try {
    const updatedResource = await updateProjectResource(projectId, personId, data);
    return { success: true, resource: updatedResource };
  } catch (error) {
    console.error('Action error:', error);
    return { success: false, error: 'Failed to update project resource' };
  }
}

/**
 * Creates a new project resource assignment
 * @param {Partial<VProjectResources>} data - Resource assignment data
 * @returns {Promise<{success: boolean, resource?: VProjectResources, error?: string}>}
 */
export async function createProjectResourceAction(data: Partial<VProjectResources>) {
  try {
    const newResource = await createProjectResource(data);
    return { success: true, resource: newResource };
  } catch (error) {
    console.error('Action error:', error);
    return { success: false, error: 'Failed to create project resource' };
  }
}

/**
 * Deletes a project resource assignment
 * @param {string} projectId - Project identifier
 * @param {string} personId - Person identifier
 * @returns {Promise<{success: boolean, error?: string}>}
 */
export async function deleteProjectResourceAction(projectId: string, personId: string) {
  try {
    await deleteProjectResource(projectId, personId);
    return { success: true };
  } catch (error) {
    console.error('Action error:', error);
    return { success: false, error: 'Failed to delete project resource' };
  }
}

/**
 * Updates a person's information
 * @param {string} personId - Person identifier
 * @param {Partial<VPerson>} data - Updated person data
 * @returns {Promise<{success: boolean, person?: VPerson, error?: string}>}
 */
export async function updatePersonAction(personId: string, data: Partial<VPerson>) {
  try {
    const updatedPerson = await updatePerson(personId, data);
    return { success: true, person: updatedPerson };
  } catch (error) {
    console.error('Action error:', error);
    return { success: false, error: 'Failed to update person' };
  }
}

/**
 * Creates a new person
 * @param {Partial<VPerson>} data - Person data to create
 * @returns {Promise<{success: boolean, person?: VPerson, error?: string}>}
 */
export async function createPersonAction(data: Partial<VPerson>) {
  try {
    const newPerson = await createPerson(data);
    return { success: true, person: newPerson };
  } catch (error) {
    console.error('Action error:', error);
    return { success: false, error: 'Failed to create person' };
  }
}

/**
 * Deletes a person
 * @param {string} personId - Person identifier
 * @returns {Promise<{success: boolean, error?: string}>}
 */
export async function deletePersonAction(personId: string) {
  try {
    await deletePerson(personId);
    return { success: true };
  } catch (error) {
    console.error('Action error:', error);
    return { success: false, error: 'Failed to delete person' };
  }
}

/**
 * Updates a role
 * @param {string} roleId - Role identifier
 * @param {Partial<VRole>} data - Updated role data
 * @returns {Promise<{success: boolean, role?: VRole, error?: string}>}
 */
export async function updateRoleAction(roleId: string, data: Partial<VRole>) {
  try {
    const updatedRole = await updateRole(roleId, data);
    return { success: true, role: updatedRole };
  } catch (error) {
    console.error('Action error:', error);
    return { success: false, error: 'Failed to update role' };
  }
}

/**
 * Creates a new role
 * @param {Partial<VRole>} data - Role data to create
 * @returns {Promise<{success: boolean, role?: VRole, error?: string}>}
 */
export async function createRoleAction(data: Partial<VRole>) {
  try {
    const newRole = await createRole(data);
    return { success: true, role: newRole };
  } catch (error) {
    console.error('Action error:', error);
    return { success: false, error: 'Failed to create role' };
  }
}

/**
 * Deletes a role
 * @param {string} roleId - Role identifier
 * @returns {Promise<{success: boolean, error?: string}>}
 */
export async function deleteRoleAction(roleId: string) {
  try {
    await deleteRole(roleId);
    return { success: true };
  } catch (error) {
    console.error('Action error:', error);
    return { success: false, error: 'Failed to delete role' };
  }
}

/**
 * Updates a category
 * @param {string} categoryId - Category identifier
 * @param {Partial<VCategory>} data - Updated category data
 * @returns {Promise<{success: boolean, category?: VCategory, error?: string}>}
 */
export async function updateCategoryAction(categoryId: string, data: Partial<VCategory>) {
  try {
    const updatedCategory = await updateCategory(categoryId, data);
    return { success: true, category: updatedCategory };
  } catch (error) {
    console.log('Action error:', error);
    return { success: false, error: 'Failed to update category' };
  }
}

/**
 * Creates a new category
 * @param {Partial<VCategory>} data - Category data to create
 * @returns {Promise<{success: boolean, category?: VCategory, error?: string}>}
 */
export async function createCategoryAction(data: Partial<VCategory>) {
  try {
    const newCategory = await createCategory(data);
    return { success: true, category: newCategory };
  } catch (error) {
    console.error('Action error:', error);
    return { success: false, error: 'Failed to create category' };
  }
}

/**
 * Deletes a category
 * @param {string} categoryId - Category identifier
 * @returns {Promise<{success: boolean, error?: string}>}
 */
export async function deleteCategoryAction(categoryId: string) {
  try {
    await deleteCategory(categoryId);
    return { success: true };
  } catch (error) {
    console.error('Action error:', error);
    return { success: false, error: 'Failed to delete category' };
  }
}

/**
 * Fetches project budget report
 * @param {string} projectId - Project identifier
 * @returns {Promise<{success: boolean, data?: any[], error?: string}>}
 */
export async function fetchProjectReportAction(projectId: string) {
  try {
    const budgetReport = await fetchProjectBudgetReport(
      projectId,
      new Date('1900-01-01'),
      new Date('2100-01-01')
    );
    return { success: true, data: budgetReport };
  } catch (error) {
    console.error('Action error:', error);
    return { success: false, error: 'Failed to fetch project budget' };
  }
}

/**
 * Updates project category budget
 * @param {string} projectId - Project identifier
 * @param {string} categoryId - Category identifier
 * @param {number} budget - New budget amount
 * @returns {Promise<{success: boolean, error?: string}>}
 */
export async function updateBudgetAction(
  projectId: string,
  categoryId: string,
  budget: number
) {
  try {
    console.log("UPDATE project_budget", projectId, categoryId, budget)
    await updateProjectCategoryBudget(projectId, categoryId, budget);
    return { success: true };
  } catch (error) {
    console.error('Action error:', error);
    return { success: false, error: 'Failed to update category budget' };
  }
}

/**
 * Deletes a project
 * @param {string} id - Project identifier
 * @returns {Promise<{success: boolean, error?: string}>}
 */
export async function deleteProjectAction(id: string) {
  try {
    await deleteProject(id);
    revalidatePath('/main');
    return { success: true };
  } catch (error) {
    console.error('Action error:', error);
    return { success: false, error: 'Failed to delete project' };
  }
}

/**
 * Fetches a list of projects
 * @param {number} limit - Maximum number of projects to return
 * @param {string} [search] - Optional search term
 * @returns {Promise<{success: boolean, data?: Project[], error?: string}>}
 */
export async function fetchProjectsAction(limit: number, search?: string) {
  try {
    const projects = await fetchTopProjects(limit, search);
    return { success: true, data: projects };
  } catch (error) {
    console.error('Action error:', error);
    return { success: false, error: 'Failed to fetch projects' };
  }
}

/**
 * Fetches project budget information
 * @param {string} projectId - Project identifier
 * @returns {Promise<{success: boolean, data?: any, error?: string}>}
 */
export async function fetchProjectBudgetAction(projectId: string) {
  try {
    const budgets = await fetchProjectBudgetReport(projectId);
    return { success: true, data: budgets };
  } catch (error) {
    console.error('Action error:', error);
    return { success: false, error: 'Failed to fetch project budget sliders' };
  }
}

/**
 * Fetches all categories
 * @returns {Promise<{success: boolean, data: VCategory[], error?: string}>}
 */
export async function fetchCategoriesAction(): Promise<{ success: boolean; data: VCategory[]; error?: string }> {
  try {
    const categories = await fetchCategories();
    return {
      success: true,
      data: categories.map(cat => ({
        ...cat,
        all_columns: `${cat.category_name}`
      }))
    };
  } catch (error) {
    console.error('Failed to fetch categories:', error);
    return {
      success: false,
      data: [],
      error: 'Failed to fetch categories'
    };
  }
}

/**
 * Fetches a project by its ID
 * @param {string} projectId - Project identifier
 * @returns {Promise<{success: boolean, data?: Project, error?: string}>} Project data or error
 */
export async function fetchProjectByIdAction(
  projectId: string
): Promise<{ 
  success: boolean; 
  data?: Project; 
  error?: string 
}> {
  try {
    const project = await fetchProjectById(projectId);
    if (!project) {
      return {
        success: false,
        error: 'Project not found'
      };
    }
    return {
      success: true,
      data: project
    };
  } catch (error) {
    console.error('Failed to fetch project:', error);
    return {
      success: false,
      error: 'Failed to fetch project'
    };
  }
} 
